

# 多项式与生成函数

## 生成函数

母函数（又翻为生成函数），是求解递推关系巧妙的数学方法，他通过代数手段解决组合计数问题

先思考一个简单的问题：从数字 $1,2,3,4$ 中取出一个或多个相加（每个数字最多只能用一次）能组合成几个数？每个数有几种组合？

![image.png](https://pic-1301573324.cos.ap-chengdu.myqcloud.com/20240308143102.png)

我们构造一个多项式，把他展开

$$
(1+x)(1+x^2)(1+x^3)(1+x^4)=1+x+x^2+2x^3+2x^4+2x^5+2x^6+2x^7+x^8+x^9+x^{10}
$$

惊人的发现，每个数的组合数量和系数一样

母函数的作用就是这样：把组合问题的加法与幂级数的乘幂对应起来

普通母函数的定义：对于序列 $h_0,h_1,h_2,\cdots,$ 构造函数 $g(x)=h_0+h_1x+h_2x^2\cdots$，称 $g(x)$ 为序列 $h_0,h_1,h_2,\cdots$ 的母函数

母函数的实质是无限可微分函数的泰勒计数，有：

$$
\frac{1}{1-x}=1+x+x^2+\cdots
$$

$$
\frac{1}{1-x^2}=1+x^2+x^4+\cdots
$$

利用母函数的泰勒计数表达，有时可以简单的演算组合计数问题

在袋子中装 $n$ 个水果，要求苹果是偶数个，香蕉数是 $5$ 的倍数，句子最多 $4$ 个，梨有 $0$ 个或 $1$ 个，给出 $n$，共有多少种情况？

写出生成函数：

$$
\begin{aligned} g(x)&=(1+x^2+x^4+\cdots)(1+x^5+x^{10}+\cdots)(1+x+x^2+x^3+x^4)(1+x)\\&=\frac{1}{1-x^2}\frac{1}{1-x^5}\frac{1-x^5}{1-x}(1+x)\\&=\frac{1}{(1-x)^2}\\&=\sum\limits^{\infty}_{k=0}(n+1)x^n\end{aligned}
$$

最后一步根据牛顿二项式定理得到

### 幂级数

- 多项式：$A(x)=\sum_{i=0}^n a_i x^i$
- 形式幂级数：$A(x)=\sum_{i\ge 0} a_i x^i$

形式幂级数之间可以有一些运算：

设 $A(x)=\sum_{i\ge 0}a_ix^i, B(x)=\sum_{i\ge 0} b_i x^i$

- 加法：$A(x)+B(x)=\sum_{i\ge 0}(a_i+b_i)x^i$
- 乘法：$A(x)B(x)=\sum_{k\ge 0}(\sum_{i+j=k} a_ib_j)x^i$

我们发现，乘法和多项式乘法有共同之处

### 形式幂级数

记形式幂级数（或多项式）$A(x)$ 的 $x^n$ 项的系数为 $[x^n]A(x)$

形式幂级数的本质是序列，幂级数的本质是极限

#### 形式幂级数的逆元

- 形式幂级数 $A(x)$ 的逆元：$A(x)B(x)=1$
- 逆元存在的条件：$[x^0]A(x)\ne 0$

常见的逆：

- $A(x)=1+x+x^2+\cdots$ 的逆元为 $B(x)=1-x$
- $A(x)=1+ax+a^xx^2+\cdots$ 的逆元为 $B(x)=1-ax$
- $A(x)=C_{k-1}^0+C_{k}^1x+C_{k+1}^2x^2+C_{k+1}^3x^3+\cdots$ 的逆元为 $B(x)=(1-x)^k$，即 $A(x)=\frac{1}{(1-x)^k}=\sum_{i\ge 0}C_{i+k-1}^i x^i$

#### 形式幂级数的求导

假设 $f(x)=a_0+a_1x+a_2x^2+\cdots+a_nx^n+\cdots$

定义 $f(x)$ 的导数为 $a_1+2a_2x+\cdots+(n+1)a_{n+1}x^n+\cdots$ 记作 $f'(x)$ 或 $\frac{df(x)}{dx}$

#### 形式幂级数的积分

假设 $f(x)=a_0+a_1x+a_2x^2+\cdots+a_nx^n+\cdots$

定义 $f(x)$ 的积分为 $a_0x+\frac{a_1}{2}x^2+\cdots+\frac{a_{n-1}}{n}x^n+\cdots$ 记作 $\int f(x)dx$

#### 形式幂级数的复合

假设 $f(x)=a_1x+\cdots+a_nx^n+\cdots$，$g(x)=b_0+b_1x+\cdots+b_nx^n+\cdots$

$g$ 复合 $f$ 定义为 $c_0+c_1x+\cdots+c_nx^n+\cdots$，满足 $c_0=b_0,c_n=\sum_{k=1}^n b_k\sum_{i_1+i_2+\cdots+i_k=n}a_{i_1}a_{i_2}\cdots a_{i_k}$，记为 $g(f(x))$

![image-20241031172927051](https://pic-1301573324.cos.ap-chengdu.myqcloud.com/20241031172927.png)

#### 形式幂级数的其他运算

- $\exp(x)=\sum_{n\ge 0} \frac{1}{n!}x^n$
- $\ln(1+x)=\sum_{n\ge 1}\frac{(-1)^{n+1}}{n}x^n$
- 设形式幂级数 $f(x)$ 满足 $[x^0]f(x)=0$ 由此可以定义 $\exp(f(x))$ 和 $\ln(f(x)+1)$，或者可以定义 $[x^0]f(x)=1$ 则可以计算 $\ln(f(x))$

![image-20241031173838965](https://pic-1301573324.cos.ap-chengdu.myqcloud.com/20241031173839.png)

### 常生成函数

一个数列 $\{a_n\}$ 对应的常数生成函数为 $A(x)=\sum_{n\ge 0} a_nx^n$

> 例: 有两种物品，其中取 $i$ 个第 $1$ 种物品的方案数为 $a_i$，取 $j$ 个第二种物体的方案数为 $b_j$，求取 $k$ 个物体的方案数

设 $A(x)=\sum_{i\ge 0} a_ix^i, B(x)=\sum_{j\ge 0} b_jx^j$

答案为 $C(x)=A(x)B(x)$

#### 递推关系

> 斐波那契数列满足 $a_0=0,a_1=1,a_n=a_{n-1}+a_{n-2}(n\ge 2)$，求其生成函数

设 $A(x)=\sum_{n\ge 0} a_nx^n$

$$
\begin{aligned} 
A(x)&=a_0+a_1x+a_2x^2+\cdots\\
&=0+x+(a_0+a_1)x^2+(a_1+a_2)x^3+\cdots+(a_{n-2}+a_{n-1})x^n+\cdots\\
&=x+(a_1x^2+a_2x^3+a_3x^4+\cdots)+(a_1x^3+a_2x^4+\cdots)\\
&=x+xA(x)+x^2A(x)\\
\end{aligned}
$$

解得 $A(x)=\frac{x}{1-x-x^2}$

我们可以通过这个常生成函数来求数列的第 $n$ 项  

把分数拆开，有：

$$
A(x)=\frac{x}{1-x-x^2}=x(\frac{c}{1-ax}+\frac{d}{1-bx})
$$

那么： $[x^n]A(x)=c\cdot a^{n}+d\cdot b^{n}$

上面的 $a,b,c,d$ 可以使用待定系数法求解

### 指数生成函数

一个数列 $\{a_n\}$ 对应的指数生成函数为 $A(x)=\sum\limits_{n\ge 0} a_n\frac{x^n}{n!}$

> 有两个物体，其中取 $i$ 个第 $1$ 种物品的方案数为 $a_i$，取 $j$ 个第二种物体的方案数为 $b_j$，求取 $k$ 个物体并排成一列的方案数

设 $A(x)=\sum_{i\ge 0} a_i\frac{x^i}{i!}, B(x)=\sum_{j\ge 0} b_j\frac{x^j}{j!}$

$$
\begin{aligned}
c_k&=\sum_{i=0}^k\binom{k}{i}a_ib_{k-i}\\
&=\sum\limits_{i=0}^k\frac{k!}{i!(k-i)!}a_ib_{k-i}\\
\frac{c_k}{k!}&=\sum\limits_{i=0}^k\frac{a_i}{i!}\frac{b_{k-i}}{(k-i)!}\\
C(x)&=A(x)B(x)
\end{aligned}
$$

所以答案为 $C(x)=A(x)B(x)$ 

<img src="https://pic-1301573324.cos.ap-chengdu.myqcloud.com/20240721211638.png" alt="image.png" style="zoom: 50%;" />

- $\exp(x)=1+x+\frac{x^2}{2!}+\cdots=\sum\limits_{n\ge 0} \frac{x^n}{n!}$
- $\exp(nx)=1+nx+\frac{n^2x^2}{2!}+\cdots=\sum\limits_{n\ge 0} \frac{n^nx^n}{n!}$

使用 $\exp$ 函数就可以实现生成函数之间的运算了，比如 $\exp(a)\exp(b)=\exp(a+b)$

## FFT

朴素多项式乘法，求逆，开根号等的复杂度为 $O(n^2)$

FFT / NTT 可以 $O(n\log n)$ 内实现两个 $n$ 次多项式的乘积

### 多项式的表示形式

假设 $f(x)$ 是一个 $n$ 次多项式，则 $f(x)$ 的系数表示为 $f(x)=a_nx^n+a_{n-1}x^{n-1}+\cdots+a_0$

则 $f(x)$ 的点值表示为 $(x_0,f(x_0)),(x_1,f(x_1)),\cdots,(x_n,f(x_n))$

那么也就是说 $n+1$ 个点值可以表示一个 $n$ 次多项式

在点值表示下 $n$ 次多项式的乘法复杂度为 $O(n)$

### 复数与单位根

> 复数的指数形式
>
> $a+b_i=re^{i\theta}$，其中 $t=\sqrt{a^2+b^2}$，$tan(\theta)=\frac{b}{a}$

> 单位根
>
> $x^n=1$ 在复数域上的根称为 $n$ 次单位根。$n$ 次单位根有 $n$ 个，形式为 $w^k_n=e^{i\frac{2k\pi}{n}}$

单位根的性质：

- $w^k_n=w^{2k}_{2n}$
- $w^{k+n}_{2n}=-w^{k}_{2n}$

### 快速傅里叶变换

> DFT(离散傅里叶变换)
>
> 将多项式 $A(x)=a_0+a_1x+\cdots+a_{n-1}x^{n-1}$ 转化为其点值形式
> $(w_n^k,A(w_n^k)),(k=0,1,\cdots,n-1)$

这里如何求这个 $A(w_n^k)=d_k$

这里有傅里叶变换的公式：

$$
d_k=\sum\limits_{i=0}^{n-1}a_i\times w_n^{ik}
$$

由于这个式子是一个线性的，所以我们能写成矩阵的形式

$$
\begin{pmatrix}
d_0\\ d_1\\ d_2\\ \vdots\\d_{n-1}
\end{pmatrix}
=
\begin{pmatrix}
w_{n}^{0\times0} & w_{n}^{0\times 1} & w_{n}^{0\times 2} & \cdots & w_{n}^{0\times (n-1)}\\
w_{n}^{1\times0} & w_{n}^{1\times 1} & w_{n}^{1\times 2} & \cdots & w_{n}^{1\times (n-1)}\\
w_{n}^{2\times0} & w_{n}^{2\times 1} & w_{n}^{2\times 2} & \cdots & w_{n}^{2\times (n-1)}\\
\vdots & \vdots & \vdots & \ddots & \vdots\\
w_{n}^{(n-1)\times0} & w_{n}^{(n-1)\times 1} & w_{n}^{(n-1)\times 2} & \cdots & w_{n}^{(n-1)\times (n-1)}
\end{pmatrix}
\begin{pmatrix}
a_0\\ a_1\\ a_2\\ \vdots\\a_{n-1}
\end{pmatrix}
$$

但是我们暴力求 $\{d\}$ 也是 $O(n^2)$ 的，现在考虑一种分治做法

我们有：$A(x)=a_0+a_1x+\cdots+a_{n-1}x^{n-1}$

把 $A(x)$ 拆成奇数项和偶数项：$A(x)=(a_0+a_2x^2+\cdots+a_{n-2}x^{n-2})+(a_1x+a_3x^3+a_5x^5+\cdots+a_{n-1}x^{n-1})$

设

$$
\begin{aligned}
B(x)=a_0+a_2x+\cdots+a_{n-2}x^{n/2-1}\\
C(x)=a_1+a_3x+\cdots+a_{n-1}x^{n/2-1}
\end{aligned}
$$

则 $A(x)=B(x^2)+xC(x^2)$

- 当 $0\le k < n/2$ 时

$$
\begin{aligned}
A(w^k_{n})&=B(w^{2k}_n)+w^k_nC(w_n^{2k})\\
&=B(w^{k}_{n/2})+w^{k}_nC(w^k_{n/2})
\end{aligned}
$$

- 当 $n/2 < k$ 时

不妨把 $k$ 减小 $n/2$ 继续把 $k$ 控制在 $0\le k < n/2$ 的范围内

$$
\begin{aligned}
A(w^{k+n/2}_{n})&=B(w^{2k+n}_n)+w^{k+n/2}_{n}C(w^{2k+n}_n)\\
&=B(w^{2k}_n)+w^{k+n/2}_{n}C(w^{2k}_n)\\
&=B(w_{n/2}^{k})+w_n^{k+n/2}C(w^{k}_{n/2})\\
&=B(w_{n/2}^k)-w_n^kC(w^k_{n/2})
\end{aligned}
$$

> IDFT(逆离散傅里叶变换)
>
> 将多项式的点值表示 $(w_n^k,b_k)$, $(k=0,1,\cdots,n-1)$ 转化为其系数表示 $A(x)=a_0+a_1x+\cdots+a_{n-1}x^{n-1}$

我直接给出逆变换的公式 $a_i=\frac{1}{n}\sum\limits_{k=0}^{n-1}b_kw_n^{-ik}$

但是现在要思考如何理解这个公式

对于上面那个 DFT 的变换的矩阵

$$
A\Omega=D
$$

现在相当于已知 $\Omega$ 和 $D$ 求 $A$，那么只需要求出 $\Omega^{-1}$ 即可

尝试构造 $\Omega^{-1}$，我们尝试共轭矩阵 $\overline{\Omega}$ 

$$
\begin{aligned}
\Omega \cdot \overline{\Omega}=P=
\begin{pmatrix}
w_{n}^{0\times0} & w_{n}^{0\times 1} & w_{n}^{0\times 2} & \cdots & w_{n}^{0\times (n-1)}\\
w_{n}^{1\times0} & w_{n}^{1\times 1} & w_{n}^{1\times 2} & \cdots & w_{n}^{1\times (n-1)}\\
w_{n}^{2\times0} & w_{n}^{2\times 1} & w_{n}^{2\times 2} & \cdots & w_{n}^{2\times (n-1)}\\
\vdots & \vdots & \vdots & \ddots & \vdots\\
w_{n}^{(n-1)\times0} & w_{n}^{(n-1)\times 1} & w_{n}^{(n-1)\times 2} & \cdots & w_{n}^{(n-1)\times (n-1)}
\end{pmatrix}
\begin{pmatrix}
w_{n}^{-0\times0} & w_{n}^{-0\times 1} & w_{n}^{-0\times 2} & \cdots & w_{n}^{-0\times (n-1)}\\
w_{n}^{-1\times0} & w_{n}^{-1\times 1} & w_{n}^{-1\times 2} & \cdots & w_{n}^{-1\times (n-1)}\\
w_{n}^{-2\times0} & w_{n}^{-2\times 1} & w_{n}^{-2\times 2} & \cdots & w_{n}^{-2\times (n-1)}\\
\vdots & \vdots & \vdots & \ddots & \vdots\\
w_{n}^{-(n-1)\times0} & w_{n}^{-(n-1)\times 1} & w_{n}^{-(n-1)\times 2} & \cdots & w_{n}^{-(n-1)\times (n-1)}
\end{pmatrix}
\end{aligned}
$$

观察答案矩阵 $P$ 的第 $i$ 行 第 $i$ 列

$$
P=\sum\limits_{k=0}^{n-1}w_n^{i\times k} w_n^{-k\times j}=\sum\limits_{k=0}^{n-1}w_n^{(i-j)\times k}
$$

我们发现这是一个公差为 $w_n^{i-j}$ 的等差数列求和，根据等差数列求和公式

$$
\sum\limits_{k=0}^{n-1}w_n^{(i-j)\times k}=
\begin{cases}
n, \ i=j\\
\frac{1-(w_n^{i-j})^n}{1-w_n^{i-j}}=0, \ i\ne j\\
\end{cases}
$$

得出答案矩阵为：

$$
\begin{pmatrix}
n & 0 & 0 & \cdots & 0\\
0 & n & 0 & \cdots & 0\\
0 & 0 & n & \cdots & 0\\
\vdots & \vdots & \vdots & \ddots & \vdots\\
0 & 0 & 0 & \cdots & n
\end{pmatrix}=nI
$$

$\Omega \cdot \overline{\Omega}=nI$， $\Omega^{-1}=\frac{1}{n}\overline{\Omega}$

这样就可以求出 $D=\frac{1}{n}\overline{\Omega} A$，也就是我们上面的公式 

$$
a_i=\frac{1}{n}\sum\limits_{k=0}^{n-1}b_kw_n^{-ik}
$$

现在我们已知了 DFT 和 IDFT 的公式，那么我们就可以进行 FFT 了

<img src="https://pic-1301573324.cos.ap-chengdu.myqcloud.com/20240722204920.png" alt="image.png" style="zoom:33%;" />

直接来看代码实现

首先，我们需要一个复数类，尽管 C++ 有复数类，常数太大了

```cpp
struct Complex {
    double x, y;
    Complex (double x = 0, double y = 0) : x(x), y(y) {}
};

Complex operator + (Complex a, Complex b) { return Complex(a.x + b.x, a.y + b.y); }
Complex operator - (Complex a, Complex b) { return Complex(a.x - b.x, a.y - b.y); }
Complex operator * (Complex a, Complex b) { return Complex(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); }
```

递归实现 FFT

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 1 << 22;
const double eps = 1e-6, pi = acos(-1);

complex<double> a[MAXN], b[MAXN], c[MAXN];
int n, m;

void FFT(complex<double> *a, int n, int inv) { // inv 为 1 时为 FFT, inv 为 -1 时为 IFFT
    if (n == 1) return;
    int mid = n >> 1;
    complex<double> A1[mid + 1], A2[mid + 1];
    for (int i = 0; i <= n; i += 2) {
        A1[i >> 1] = a[i];
        A2[i >> 1] = a[i + 1];
    }
    FFT(A1, mid, inv); FFT(A2, mid, inv);
    complex<double> w0(1, 0), wn(cos(2 * pi / n), inv * sin(2 * pi / n));
    for (int i = 0; i < mid; i++, w0 *= wn) {
        a[i] = A1[i] + w0 * A2[i];
        a[i + mid] = A1[i] - w0 * A2[i];
    }
}

int main() {
    scanf("%d %d", &n, &m);
    for (int i = 0; i <= n; i++) {double x; scanf("%lf", &x); a[i].real(x);}
    for (int i = 0; i <= m; i++) {double x; scanf("%lf", &x); b[i].real(x);}
    int len = 1 << max((int)ceil(log2(n + m)), 1); //由于FFT需要项数为2的整数次方倍，所以多项式的次数len为第一个大于 n+m 的二的正整数次方
    FFT(a, len, 1); FFT(b, len, 1);
    for (int i = 0; i < len; i++) c[i] = a[i] * b[i];
    FFT(c, len, -1);
    for (int i = 0; i <= n + m; i++)
        printf("%.0f ",(c[i].real() / len + eps));
    return 0;
}
```

### 蝴蝶变换

<img src="https://pic-1301573324.cos.ap-chengdu.myqcloud.com/20241011235630.png" alt="image-20241011235630473" style="zoom: 67%;" />

观察原序列和后序列的二进制之后，惊奇的发现，其实际上就是把二进制翻转了，我们可以用 $O(32n)$ 来实现

实际上可以用 $O(n)$ 的递推式来实现，定义 $R(n)$ 表示 $n$ 二进制反转后对应的值，有递推式：

$$
R(n)=R(n/2)+(n\&1)\times\frac{n}{2}
$$

通过这个递推式能求出 $R(n)$

```cpp
void change(complex<double> A[], int n) {
    for (int i = 0; i < n; i++)
        R[i] = (R[i >> 1] >> 1) + ((i & 1) ? n >> 1 : 0);
    for (int i = 0; i < n; i++)
        if (i < R[i]) swap(A[i], A[R[i]]); // 只需要换一次
}
```



然后有了这个思路，就可以直接构造出最后一层的下标然后从下往上模拟递归合并的过程了

<img src="https://pic-1301573324.cos.ap-chengdu.myqcloud.com/20241012001518.png" alt="image.png" style="zoom: 50%;" />

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 1 << 22;
const double eps = 1e-6, pi = acos(-1);

complex<double> a[MAXN], b[MAXN], c[MAXN];
int R[MAXN];
int n, m;

void change(complex<double> A[], int n) {
    for (int i = 0; i < n; i++)
        R[i] = (R[i >> 1] >> 1) + ((i & 1) ? n >> 1 : 0);
    for (int i = 0; i < n; i++)
        if (i < R[i]) swap(A[i], A[R[i]]);
}

void FFT(complex<double> *a, int n, int inv) { // inv 为 1 时为 FFT, inv 为 -1 时为 IFFT
    change(a, n);
    for (int m = 2; m <= n; m <<= 1) {
        complex<double> w1(cos(2 * pi / m), inv * sin(2 * pi / m));
        for (int i = 0; i < n; i += m) {
            complex<double> wk(1, 0);
            for (int j = 0; j < m / 2; j++, wk *= w1) {
                auto x = a[i + j], y = wk * a[i + j + m / 2];
                a[i + j] = x + y; a[i + j + m / 2] = x - y;
            }
        }
    }
}

int main() {
    scanf("%d %d", &n, &m);
    for (int i = 0; i <= n; i++) {double x; scanf("%lf", &x); a[i].real(x);}
    for (int i = 0; i <= m; i++) {double x; scanf("%lf", &x); b[i].real(x);}
    int len = 1 << max((int)ceil(log2(n + m)), 1); //由于FFT需要项数为2的整数次方倍，所以多项式的次数len为第一个大于 n+m 的二的正整数次方
    FFT(a, len, 1); FFT(b, len, 1);
    for (int i = 0; i < len; i++) c[i] = a[i] * b[i];
    FFT(c, len, -1);
    for (int i = 0; i <= n + m; i++)
        printf("%.0f ",(c[i].real() / len + eps));
    return 0;
}
```

## NTT

### 原根

> 欧拉定理
>
> 若正整数 $m,a$，满足 $\gcd(a,m)=1$，则 $a^{\varphi (n)}\equiv 1 \pmod{m}$

> 阶
>
> 若正整数 $m,a$，满足 $\gcd(a,m)=1$，则 $a^k\equiv 1 \pmod{m}$ 的最小正整数 $k$ 称为 $a$ 对模 $m$ 的阶，记作 $\delta_m(a)$

> 若 $\delta_m(a)=\varphi(m)$，则称 $a$ 为 $m$ 的一个原根

阶的性质

假设 $(a,m)=1,\delta=\delta_m(a)$，则

- $a^0,a^1,\cdots,a^{\delta -1}$ 在模 $m$ 意义下两两不同
- $a^{\gamma}\equiv a^{\gamma'}\pmod{m}\Leftrightarrow \gamma\equiv \gamma'\pmod{m}$
- $\delta | \varphi(m)$

> 原根的存在与判定
>
> 只有模 $2,4,p^a,2p^a$ 存在原根（$p$ 是奇质数）

> 原根的判定定理
>
> 设 $m>1$，$g$ 为正整数且 $(g,m)=1$。则 $g$ 是 $m$ 的原根当且仅当对于任意 $\varphi(m)$ 的质因子 $q_i$，$g^{\frac{\varphi(m)}{q_i}}\not \equiv 1\pmod{m}$

如何寻找原根，假设这里我们需要寻找 $p$ 的原根，那么有 $g^0,g^1,\cdots,g^{\varphi(p)-1}$ 在模 $p$ 意义下各不相同，如果 $p$ 是一个质数，那么这里有 $\varphi(p)=p-1$

一个数原根的个数为 $\varphi(\varphi(p))$ 但是第一个原根往往不是特别大，所以从小到大枚举 $rt$ 然后 $O(p)$ 去 check

若 $rt$ 不是原根，那么一定存在 $0\le i < j \le \varphi(n)-1$ 使得 $g^i\equiv g^j \pmod{p}$ 那么有 $g^{j-i}\equiv 1\pmod{p}$ ，所以说如果出现一个 $0<d=j-i<\varphi(p)$ 使得 $g^d\equiv 1\pmod{p}$，那么就说明 $rt$ 不是原根

```cpp
int rt = 1; // P 是一个质数
while (true) {
    bool ok = true;
    int v = 1;
    for (int i = 1; i < P - 1; i++) {
        v = v * rt % P;
        if (v == 1) {
            ok = false;
            break;
        }
    }
    if (ok) break;
    rt += 1;
}
```

设 $d=j-i$，又有 $g^{\varphi(n)}\equiv 1\pmod{p}$，所以有 $d|\varphi(n)$

于是，我们只需要预处理出 $\varphi(n)$ 的的因数 $\{e\}$，对于一个 $rt$ 如果存在一个 $rt^{e_i}\equiv 1\pmod{p}$ 那么 $rt$ 就不是原根


> 指标
>
> 对于质数 $p$，假设 $g$ 是 $p$ 的一个原根，则 $g^0,g^1,g^{p-2}$ 在模 $p$ 意义下是 $1,2,\cdots,p-1$ 的一个排列。假设对于 $1\le x \le p-1$ 有 $g^c\equiv x \pmod{p}$ 则称 $x$ 的指标为 $c$，记作 $\text{ind}(x)=c$

指标有着非常优秀的性质，也被称为离散对数：$\forall 1\le x,y<p, \text{ind}(xy)\equiv \text{ind}(x)+\text{ind}(y)\pmod{\varphi(p))}$

如何求一个 $\text{ind}(x)$ 可以使用 BSGS 算法

求所有的 $\text{ind(x)}$ 可以使用 $O(n)$ 的递推

```cpp
vector<ll> lg(P, 0);
for (int i = 0, v = 1; i < P - 1; i++) {
    lg[v] = i;
    v = v * rt % P;
}
```

### NTT 实现

假设质数 $p=r2^l+1$ ，$g$  是 $p$  的原根，和 FFT 类似，我们用 $g_n=g^{\frac{p-1}{n}}$ 代替 $w_n$

我们发现，这样子去选取 $g_n$ 一样满足一些性质：

- $g_{2n}^{2k} \equiv g_n^k \ (\text{mod}\ p), \ (2n \leq 2^l)$
- $g_{2n}^n \equiv -1 \ (\text{mod}\ p), \ (2n \leq 2^l)$
- $\sum_{k=0}^{n-1} g_n^{ik} g_n^{-kj} \equiv \begin{cases} n,\text{if} \ i = j \\ 0, \text{otherwise} \end{cases}$

和 FFT 类似，只不过这里用原根来替换单位根，来进行一个模意义下的运算，FFT 中的 DFT，IDFT，依然成立

- NTT 的优点：快，精确
- NTT 的限制：模数需要是满足 $p=r2^l+1$ 的质数 $p$，

下面有些常见的模数：

- $65537=2^{16}+1,g=3$
- $998244353=119\times 2^{23}+1,g=3$
- $1004535809=479\times2^{21}+1,g=3$
- $4179340454199820289=29\times 2^{57}+1,g=3$

**非递归的 NTT**

```cpp
//NTT

int rev[MAXN], limit, bit;

void NTT (vector<ll> &a, int op) {
    for (int i = 0; i < limit; i++)
        if (i < rev[i]) swap(a[i], a[rev[i]]);
    
    for (int m = 2; m <= limit; m <<= 1) {
        ll gn = qpow(3, (MOD - 1) / m); 
        if (op == -1) gn = qpow(gn, MOD - 2);
        for (int i = 0; i < limit; i += m) {
            ll gk = 1;
            for (int j = 0; j < m / 2; j++) {
                ll x = a[i + j], y = gk * a[i + j + m / 2] % MOD;
                a[i + j] = (x + y) % MOD;
                a[i + j + m / 2] = (x - y + MOD) % MOD;
                gk = gk * gn % MOD;
            }
        }
    }
}

void convolution(vector<ll> A, vector<ll> B, vector<ll> &C) {
    int n = A.size() - 1, m = B.size() - 1;
    limit = 1, bit = 0;
    while (limit <= n + m) limit <<= 1, bit += 1;
    for (int i = 0; i < limit; i++)
        rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (bit - 1));

    A.resize(limit), B.resize(limit); C.resize(limit);
    for (int i = n + 1; i < limit; i++) A[i] = 0;
    for (int i = m + 1; i < limit; i++) B[i] = 0;
    
    NTT(A, 1), NTT(B, 1);


    for (int i = 0; i < limit; i++)
        C[i] = A[i] * B[i] % MOD;
    NTT(C, -1);
    ll inv = qpow(limit, MOD - 2);
    for (int i = 0; i < limit; i++)
        C[i] = C[i] * inv % MOD;
}
```

## 牛顿迭代

给定多项式 $g(x)$，求满足 $g(f(x))=0\pmod{x^n}$ 的形式幂级数 $f(x)$

当 $n=1$ 时，$[x^0]g(f(x))=0$ 可以求出

假设现在已经得到了 $\pmod{x^{\lceil \frac{n}{2}\rceil}}$ 的解 $f_0(x)$

有递归式：

$$
f(x)\equiv f_0(x)-\frac{g(f_0(x))}{g'(f_0(x))}\pmod{x^n}
$$

## 多项式求逆

给定函数 $h(x)$，有方程

$$
g(f(x))=\frac{1}{f(x)}-h(x)\equiv0\pmod{x^n}
$$

应用牛顿迭代可得：

$$
\begin{aligned}
f(x)& \equiv f_9(x)-\frac{\frac{1}{f_0(x)}-h(x)}{-\frac{1}{f_0^2(x)}}\\
&\equiv 2f_0(x)-f_0^2(x)h(x)
\end{aligned}
$$
于是，我们就得到了 $f(x)$ 的递推是

根据主定理，时间复杂度为 $O(n\log n)$

## 多项式开方

设给定函数为 $h(x)$ 有方程：

$$
g(f(x))=f^2(x)-h(x)\equiv 0\pmod{x^n}
$$

 应用牛顿迭代可得：

$$
\begin{aligned}
f(x)&\equiv f_0-\frac{f^2_0(x)-h(x)}{2f_0(x)}\pmod{x^n}\\
&\equiv \frac{f_0^2(x)+h(x)}{2f_0(x)}\pmod{x^n}
\end{aligned}
$$

时间复杂度 $O(n\log n)$

## 多项式 exp

给定函数 $h(x)$，有方程：

$$
g(f(x))=\ln f(x)-h(x)\pmod{x^n}
$$

应用牛顿迭代可得：

$$
\begin{aligned}
f(x)&\equiv f_0(x)-\frac{\ln f_0(x)-h(x)}{\frac{1}{f_0(x)}}\pmod{x^n}\\
&\equiv f_0(x)(1-\ln f_0(x)+h(x))\pmod{x^n}
\end{aligned}
$$

 时间复杂度为 $O(n\log n)$

## 拉格朗日差值

$n$ 个点值 $(x_i,y_i),\ (1\le i \le n)$，满足 $x_i\ne x_j,\ (i\ne j)$，它们唯一确定一个 $n-1$ 次多项式 $f(x)$

$$
f(x)=\sum_{i=1}^n y_i\prod_{j\ne i}\frac{x-x_j}{x_i-x_j}
$$


拉格朗日差值定理用于点值表示转化成多项式形式，我们需要构造出一个多项式，满足 $f(x_i)=y_i$

首先，把 $f(x)$ 拆成 $n$ 个函数相加的形式 $f(x)=f_1(x)+f_2(x)+\cdots+f_n(x)$

特别的，我们可以令 $f_i(x)$ 当且仅当在 $x=x_i$ 时 $f(x_i)=y_i$，其他时候都为 $0$

那么很显然可以构造出 $f_i(x)=A\prod_{i\ne j}(x-x_j)$，其中 $A$ 是一个系数，我们把 $f_i(x_i)=y_i$ 带入

$$
\begin{aligned}
&f_i(x_i)=A\prod_{i\ne j}(x_i-x_j)=y_i\\
\Longleftrightarrow &\ A=\frac{y_i}{\prod\limits_{i\ne j}(x_i-x_j)}
\end{aligned}
$$

回代：

$$
f_i(x)=\frac{y_i}{\prod\limits_{i\ne j}(x-x_j)}\prod_{i\ne j}(x-x_j)=y_i\prod_{i\ne j}\frac{x-x_j}{x_i-x_j}
$$

则：

$$
f(x)=\sum_{i=1}^nf_i(x)=\sum_{i=1}^n y_i\prod_{j\ne i}\frac{x-x_j}{x_i-x_j}
$$

考虑计算

- 特殊情况一：

只需要求一个 $f(x_0)$，那么暴力 $O(n^2)$ 算即可

- 特殊情况二：

只需要求一个 $f(x_o)$，并且满足 $x_i=i$，是可以优化到 $O(n)$ 的