递归，简单来说，就是“自己调用自己”。如果你想真正掌握递归，首先要掌握递归（

来看一个最基础的例子：

```cpp
void f() {
    f();
}
```

这个函数一旦被调用，就会不停地调用自己，像照镜子一样无穷无尽。最终，程序会因为“栈溢出”而崩溃。为什么？因为每一次函数调用，都会在内存中开辟一块空间，而这个过程没有尽头，内存迟早会被耗尽。

所以，**递归的关键在于“递归出口”**。递归出口就像迷宫的出口，告诉递归什么时候该停下来。如果没有出口，递归就会永远在迷宫里打转。

---

比如，计算正整数 n 的阶乘 \( n! \)，递归写法如下：

```cpp
int factorial(int n) {
    if (n == 1) return 1; // 递归出口
    return n * factorial(n - 1); // 递归调用
}
```

这里，`if (n == 1) return 1;` 就是递归的出口。每次调用 `factorial`，都会把 n 减 1，直到 n 变成 1，这时递归停止，开始一层层“回溯”返回结果。

---

除了阶乘，递归还可以用来计算**斐波那契数列**。斐波那契数列的定义是：

- 第1项是1
- 第2项是1
- 从第3项开始，每一项等于前两项之和

用递归写出来，就是这样：

```cpp
int fibonacci(int n) {
    if (n == 1 || n == 2) return 1; // 递归出口
    return fibonacci(n - 1) + fibonacci(n - 2); // 递归调用
}
```

> 这里，`n == 1 || n == 2` 就是递归出口。当 n 等于 1 或 2 时，直接返回 1。否则，每一项都等于前两项之和，也就是递归地调用自己两次。

你可以想象成爬楼梯：  

- 如果只剩1级台阶，只有1种跳法；  
- 如果只剩2级台阶，有2种跳法（一次跳两级，或者分两次跳）；  
- 如果有 n 级台阶，你可以先跳1级，剩下 n-1 级的跳法交给递归去算；也可以先跳2级，剩下 n-2 级的跳法也交给递归去算。  
- 所以总跳法就是 `fibonacci(n-1) + fibonacci(n-2)`。

---

**再来一个经典的递归问题：汉诺塔问题**

汉诺塔问题描述：有三根柱子，编号分别为A、B、C。开始时，所有圆盘都叠在A柱上，目标是把所有圆盘移动到C柱，每次只能移动一个圆盘，并且大盘不能放在小盘上面。你要怎么做？

递归解法如下：

```cpp
#include <iostream>
using namespace std;

void hanoi(int n, char from, char via, char to) {
    if (n == 1) {
        // 递归出口：只剩一个盘子，直接从from移到to
        cout << "Move disk 1 from " << from << " to " << to << endl;
        return;
    }
    // 先把上面n-1个盘子从from借助to移到via
    hanoi(n - 1, from, to, via);
    // 再把最大的盘子从from移到to
    cout << "Move disk " << n << " from " << from << " to " << to << endl;
    // 最后把n-1个盘子从via借助from移到to
    hanoi(n - 1, via, from, to);
}
```

参数说明：

- int n：表示当前要移动的盘子的数量。每次递归，n都会减小，直到只剩下1个盘子（递归出口）。

- char from：表示起始柱子的编号（比如'A'），也就是当前盘子所在的柱子。

- char via：表示辅助柱子的编号（比如'B'），在移动过程中用来“暂存”盘子。

- char to：表示目标柱子的编号（比如'C'），也就是我们最终要把盘子移到的地方。

---

你可以这样理解这几个参数：

假如你是搬运工，要把 n 个盘子从 from 搬到 to，via 就是你临时借用的“中转站”。每次递归调用，参数会发生变化，递归帮你自动安排好每一步的搬运顺序。

> 这里，`if (n == 1)` 就是递归出口。只剩一个盘子时，直接移动。否则，先递归地把上面 n-1 个盘子移到中间柱，再把最大的盘子移到目标柱，最后再递归地把 n-1 个盘子移到目标柱。

你可以把汉诺塔想象成“分而治之”的典范：每次都把问题拆成更小的同类问题，直到最简单的情况（只剩一个盘子）为止。

---

**递归的套路总结：**

1. 明确“终点”——递归出口，防止无限递归。
2. 把大问题拆成小问题，让递归帮你解决。
3. 每次递归都要离“终点”更近一步。

无论是阶乘、斐波那契数列，还是汉诺塔问题，递归的思想都是一样的：**把复杂的问题分解成更小的同类问题，直到遇到最简单的情况（递归出口）为止。**

只要掌握了这个套路，递归就不再神秘啦！